<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JVM on Ehlxr's Blog</title><link>https://3w.vercel.app/tags/JVM/</link><description>Recent content in JVM on Ehlxr's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 27 Jul 2021 09:35:05 +0000</lastBuildDate><atom:link href="https://3w.vercel.app/tags/JVM/rss.xml" rel="self" type="application/rss+xml"/><item><title>JVM TLAB</title><link>https://3w.vercel.app/2021/07/27/jvm-tlab/</link><pubDate>Tue, 27 Jul 2021 09:35:05 +0000</pubDate><guid>https://3w.vercel.app/2021/07/27/jvm-tlab/</guid><description>&lt;p>&lt;strong>TLAB（Thread Local Allocation Buffer）&lt;/strong> 线程本地分配缓存区&lt;/p>
&lt;ol>
&lt;li>由于对象一般分配在堆上，而堆是线程共用的，因此可能会有多个线程在堆上申请空间，而每一次的&lt;strong>对象分配都必须加锁保证线程同步&lt;/strong>，会使分配的效率下降。考虑到对象分配几乎是 &lt;code>Java&lt;/code> 中最常用的操作，因此 &lt;code>JVM&lt;/code> 使用了 &lt;code>TLAB&lt;/code> 这样的线程专有区域来避免多线程冲突，提高对象分配的效率。&lt;/li>
&lt;li>我们说 &lt;code>TLAB&lt;/code> 是线程独享的，但是只是在 &lt;strong>“分配”&lt;/strong> 这个动作上是线程独享的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别&lt;/li>
&lt;li>&lt;code>JVM&lt;/code> 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间 &lt;code>TLAB&lt;/code>，其大小由 &lt;code>JVM&lt;/code> 根据运行的情况计算而得，在 &lt;code>TLAB&lt;/code> 上分配对象时不需要加锁，因此 &lt;strong>JVM 在给线程的对象分配内存时会尽量的在 TLAB 上分配&lt;/strong>，在这种情况下 JVM 中分配对象内存的性能和 &lt;code>C&lt;/code> 基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配&lt;/li>
&lt;li>在 &lt;code>TLAB&lt;/code> 分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过 &lt;code>TLAB&lt;/code> 分配内存，存放在 &lt;code>Eden&lt;/code> 区，但是还是会被垃圾回收或者被移到 &lt;code>Survivor Space、Old Gen&lt;/code> 等。&lt;/li>
&lt;li>&lt;strong>“堆是线程共享的内存区域” 这句话并不完全正确&lt;/strong>，因为 &lt;code>TLAB&lt;/code> 是堆内存的一部分，它在读取上确实是线程共享的，但是在内存分配上，是线程独享的。&lt;/li>
&lt;li>&lt;code>TLAB&lt;/code> 的空间其实并不大（默认是 &lt;code>eden&lt;/code> 区空间的 &lt;code>1%&lt;/code>），所以大对象还是可能需要在堆内存中直接分配。那么，对象的内存分配步骤就是先尝试 &lt;code>TLAB&lt;/code> 分配，空间不足之后，再判断是否应该直接进入老年代，然后再确定是再 &lt;code>eden&lt;/code> 分配还是在老年代分配。&lt;/li>
&lt;/ol></description></item><item><title>JVM-垃圾回收（二）</title><link>https://3w.vercel.app/2018/08/23/jvm-gc2/</link><pubDate>Thu, 23 Aug 2018 15:15:07 +0000</pubDate><guid>https://3w.vercel.app/2018/08/23/jvm-gc2/</guid><description>&lt;blockquote>
&lt;p>接着上次 JVM 中 GC 机制的总结，这次主要复习一下垃圾收集的常用算法和 Minor GC、Full GC 相关的一些知识点。&lt;/p>
&lt;/blockquote>
&lt;h2 id="一垃圾收集算法">一、垃圾收集算法&lt;/h2>
&lt;h3 id="11-标记---清除mark-sweep">1.1 标记 - 清除（Mark-Sweep）&lt;/h3>
&lt;p>算法分成 “标记”、“清除” 两个阶段：首先标记出所有需要回收的对象（两次标记），在标记完成后统一回收所有被标记的对象。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://3w.vercel.app/imgs/img-lazy-loading.gif" data-src="https://cdn.jsdelivr.net/gh/0vo/oss/images/687148dbly1ftwah4c7cxj20gv07b0sz.jpg" alt="" />&lt;/p></description></item><item><title>JVM-垃圾回收（一）</title><link>https://3w.vercel.app/2018/08/23/jvm-gc1/</link><pubDate>Thu, 23 Aug 2018 11:25:52 +0000</pubDate><guid>https://3w.vercel.app/2018/08/23/jvm-gc1/</guid><description>&lt;p>在 JVM 运行时数据区域中，程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。&lt;/p>
&lt;h2 id="一判断对象状态">一、判断对象状态&lt;/h2>
&lt;p>JVM 在回收一个对象时，首先要判断这个对象的状态，如果判断对象为无效的（没有被任何对象或变量引用），则需要被 JVM 垃圾回收器回收。&lt;/p>
&lt;h3 id="11-引用计数算法">1.1 引用计数算法&lt;/h3>
&lt;p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数不为 0 的对象仍然存活。&lt;/p></description></item><item><title>JVM-运行时数据区域</title><link>https://3w.vercel.app/2018/04/08/jvm-runtime-data-area/</link><pubDate>Sun, 08 Apr 2018 17:30:33 +0000</pubDate><guid>https://3w.vercel.app/2018/04/08/jvm-runtime-data-area/</guid><description>&lt;p>Java 的内存区域划分绝不仅仅只是堆内存（heap）和栈内存（Stack），实际上 JVM 在执行 Java 程序的过程中会把它所管理的内存划分为以下几个数据区域：程序计数器、Java 虚拟机栈、本地方法栈、堆、方法区、运行时常量和直接内存。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://3w.vercel.app/imgs/img-lazy-loading.gif" data-src="https://cdn.jsdelivr.net/gh/0vo/oss/images/jvm-runtime-data-area.png" alt="Runtime DataArea" />&lt;/p></description></item></channel></rss>