<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>排序算法 on Ehlxr's Blog</title><link>https://3w.vercel.app/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><description>Recent content in 排序算法 on Ehlxr's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 19 Mar 2022 18:25:46 +0800</lastBuildDate><atom:link href="https://3w.vercel.app/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/rss.xml" rel="self" type="application/rss+xml"/><item><title>快速排序理解</title><link>https://3w.vercel.app/2022/03/19/quick-sort/</link><pubDate>Sat, 19 Mar 2022 18:25:46 +0800</pubDate><guid>https://3w.vercel.app/2022/03/19/quick-sort/</guid><description>&lt;p>快速排序算法核心思想，取待排序序列中的某个元素作为分区点，大于分区点的元素挪到分区点右边（从小到大排序），小于分区点的元素挪到分区点左边。然后分区点左右两边的子序列循环以上操作，直至子序列长度为 &lt;code>1&lt;/code>。&lt;/p>
&lt;p>&lt;strong>左右指针法实现思路&lt;/strong>&lt;/p>
&lt;p>1、首先定义分区点（pivot）&lt;code>p&lt;/code>，&lt;code>p&lt;/code> 一般为数组 &lt;code>a&lt;/code> 的第一个元素或最后一个元素
2、然后定义左（&lt;code>l&lt;/code>）、右（&lt;code>r&lt;/code>）两个指针分别指向数组的第一个元素（&lt;code>a[0]&lt;/code>）和最后一个元素 (&lt;code>a[a.length - 1]&lt;/code>)
3、如果 &lt;code>a[l] &amp;gt; a[p]&lt;/code>，&lt;code>l、p&lt;/code> 下标元素互换，&lt;code>l&lt;/code> 前进 &lt;code>1&lt;/code> 位
4、如果 &lt;code>a[r] &amp;lt; a[p]&lt;/code>，&lt;code>r、p&lt;/code> 下标元素互换，&lt;code>r&lt;/code> 后退 &lt;code>1&lt;/code> 位
5、如果 &lt;code>l &amp;gt;= r&lt;/code>，排序结束&lt;/p></description></item><item><title>堆排序理解</title><link>https://3w.vercel.app/2022/03/19/heap-sort/</link><pubDate>Sat, 19 Mar 2022 16:28:35 +0800</pubDate><guid>https://3w.vercel.app/2022/03/19/heap-sort/</guid><description>&lt;p>堆排序的关键是构建大（小）顶堆，堆顶元素就是最大（小）的元素，然后堆顶元素和末尾元素交换位置，再次堆化除最后一个元素外的其它元素，循环次过程即可完成排序。&lt;/p>
&lt;p>翻译成代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">public&lt;/span> &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">sort&lt;/span>&lt;span style="color:#666">(&lt;/span>&lt;span style="color:#902000">int&lt;/span> a&lt;span style="color:#666">)&lt;/span> &lt;span style="color:#666">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span>&lt;span style="color:#666">(&lt;/span>&lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> a&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#4070a0">length&lt;/span> &lt;span style="color:#666">-&lt;/span> 1&lt;span style="color:#666">;&lt;/span> i &lt;span style="color:#666">&amp;gt;&lt;/span> 0&lt;span style="color:#666">;&lt;/span> i&lt;span style="color:#666">--)&lt;/span> &lt;span style="color:#666">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buildHeap&lt;span style="color:#666">(&lt;/span>a&lt;span style="color:#666">,&lt;/span> i&lt;span style="color:#666">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// 堆顶元素和最后一个元素交换，除过最后一个元素外其它元素再次构建大顶堆
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> swap&lt;span style="color:#666">(&lt;/span>a&lt;span style="color:#666">,&lt;/span> 0&lt;span style="color:#666">,&lt;/span> i&lt;span style="color:#666">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>